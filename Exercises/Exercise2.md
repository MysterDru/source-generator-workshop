## Exercise 2 | Discover Class & Add Output


### Update the generator class

Update the generator class to contain the following:

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
    {   
        // Create a simple filter to find classes that might implement interfaces
        IncrementalValuesProvider<string> pipeline = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: NodeIsEligibleForGeneration,
            transform: TransformNode);

        context.RegisterSourceOutput(pipeline, GenerateOutput);
    }


    private static bool NodeIsEligibleForGeneration(SyntaxNode node, CancellationToken cancellationToken)
        => node is ClassDeclarationSyntax {BaseList.Types.Count: > 0};

    private static string TransformNode(GeneratorSyntaxContext generatorContext, CancellationToken cancellationToken)
        => ((ClassDeclarationSyntax) generatorContext.Node).Identifier.ValueText;

    private void GenerateOutput(SourceProductionContext context, string classIdentifier)
    {
        context.AddSource($"{classIdentifier}.g.cs", $"/// Generated code for {classIdentifier}");
    }

```

The above code snipet sets up a very basic incremental source generator.

It will look for any SyntaxNodes that represent a class declaration with at least 1 base type. In this case, both base classes and interfaces will be categorized as a base type in the syntax tree.

Once a class node has been identified, we retrieve the name of the class via the `ClassDeclarationSyntax.Identifier.ValueText`.

The resultining type is a `IncrementalValuesProvider<string>` instance that is enumerated on to generate our output.

`context.RegisterSourceOutput(pipeline, GenerateOutput)` is then invoked to add our generated code to the compilation.

Right now `GenerateOutput` simply adds a generated file with a `/// <auto-generated>` header and a file name of `ClassName.g.cs`; which we will expand on in further exercises.

### View Generated Files

If everything is working correctly, you should get a generated file for the `Book` class that looks like:

```csharp
/// Generated code for Book
```

Depending on what IDE you're using, the process of viewing the generated files is different.

#### Rider
In Rider, you can view a live output of generated files directly in the IDE. Expand `Dependencies -> .NET 8.0 -> Source Generators -> AutoProperty.Generator.AutoPropertyGenerator`, within there you should see 1 file for `Book.g.cs`.

#### Visual Studio / Visual Studio Code

Due to caching of compiler files in Visual Studio for Windows, generate files are not available for viewing live like Rider.

Similarly, VS Code does not have the ability to view generated files as a part of references.

Instead, you can add `<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>` to the property group of `AutoProperty.Sample.csproj`. Once added, whenever you build the solution, the generated files will appear in the following folder:

 `\obj\$(Configuration)\net8.0\generated\AutoProperty.Generator\AutoProperty.Generator.AutoPropertyGenerator`

 You can view the generated files from within either Visual Studio IDE by showing all files in the explorer, and expanding to the folder path above.

 ### Wraping Up

 At the conclusion of this exercise you should have a basic file generating for the Book class that is browsable via your IDE.

 We'll dive into adding some meat to the generated code in the next exercise.