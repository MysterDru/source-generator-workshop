## Exercise 4 | Generating A Partial Class

Now that we have the basis of our generator hooked up we can create some actual code.

### Prevent Compile Errors - Make your classes partial

Before we update the generator, we need to make are target classes partial classes. 

Update the book class to add the partial modifier:

`public partial class Book`

### Generate the class shell

Now we'll make some updates to the generator, our goal is to generate the following output for the Book class

```csharp
/// <auto-generated>
namespace AutoProperty.Sample
{
    partial class Book
    {
    }
}
```

#### Update TransformNode

To create our desired output, we need the class name and the namespace. So update `TransformNode` to extract the namespace name from the syntax tree.

```csharp
private static (string NamespaceName, string ClassName)? TransformNode(GeneratorSyntaxContext generatorContext,
        CancellationToken cancellationToken)
    {
        var classDeclaration = (ClassDeclarationSyntax) generatorContext.Node;
        if (classDeclaration.Parent is not BaseNamespaceDeclarationSyntax namespaceDeclarationSyntax)
        {
            return null;
        }

        return (namespaceDeclarationSyntax.Name.ToString(), classDeclaration.Identifier.ValueText);
    }
```

We change the return type to a `ValueTuple<string, string>?` to gain access to namespace and class name in the downstream pipeline.

For now, if the class declaration doesn't have an immediate parent namespace we'll skip it. 

We have to update the types in the rest of the pipeline too. 

First, update the filter pipeline so it supports the new return type.
```csharp
// change the return type to var for simplicity. 
// Will be IncrementalValuesProvider<(string, string)?>
var pipeline = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: NodeIsEligibleForGeneration,
                transform: TransformNode)
            .Where(static x => x.HasValue) // filter out null
            .Select(static (x, _) => x!.Value) // force result to value so GenerateOutput doesn't receive null values
```

Next, change the method signature of `GenerateOutput` to match our new result type.

```csharp
private static void GenerateOutput(SourceProductionContext context,
        (string NamespaceName, string ClassName) classToGenerate)
```

And finally, update the content of `GenerateOutput` to add the class shell to the output.

```csharp
private static void GenerateOutput(SourceProductionContext context,
        (string NamespaceName, string ClassName) classToGenerate)
    {   
        var sourceText = $@"/// <auto-generated>
namespace {classToGenerate.NamespaceName}
{{
    partial class {classToGenerate.ClassName}
    {{
    }}
}}";

        context.AddSource($"{classToGenerate.NamespaceName}.{classToGenerate.ClassName}.g.cs", sourceText);
    }
```

### Wrapping Up

If you build the solution after completing the above changes, you should see a `AutoProperty.Sample.Book.g.cs` created with the class shell.

You might still see the old `Book.g.cs` in the generated output folder. If so, you can delete that from disk.

If you skipped the update to adding `partial` to `Book`, after building the solution you should see a compile error:

`Duplicate definition 'AutoProperty.Sample.Book'. Possibly missing keyword 'partial'`

In the next exercise we'll work with the semantic model to get interface metadata and add it to the generated output.