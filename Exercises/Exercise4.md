## Exercise 4 | Generating A Partial Class

Now that we have the basis of our generator hooked up we can create some actual code.

### Prevent Compile Errors - Make your classes partial

Before we update the generator, we need to make are target classes partial classes. 

Update the book class to add the partial modifier:

`public partial class Book`

### Generate the class shell

Now we'll make some updates to the generator. Our goal is to generate the following output for the Book class

```csharp
/// <auto-generated>
namespace AutoProperty.Sample
{
    partial class Book
    {
    }
}
```

#### Update TransformNode

To create our desired output, we need the class name and the namespace. So update `TransformNode` to extract the namespace name from the syntax tree.

```csharp
private static (string NamespaceName, string ClassName)? TransformNode(GeneratorSyntaxContext generatorContext,
        CancellationToken cancellationToken)
    {
        var classDeclaration = (ClassDeclarationSyntax) generatorContext.Node;
        if (classDeclaration.Parent is not BaseNamespaceDeclarationSyntax namespaceDeclarationSyntax)
        {
            return null;
        }

        return (namespaceDeclarationSyntax.Name.ToString(), classDeclaration.Identifier.ValueText);
    }
```

We change the return type to a `ValueTuple<string, string>?` to gain access to namespace and class name in the downstream pipeline.

For now, if the class declaration doesn't have an immediate parent namespace we'll skip it. 

We have to update the types in the rest of the pipeline too. 

First, update the filter pipeline so it supports the new return type.
```csharp
// change the return type to var for simplicity. 
// Will be IncrementalValuesProvider<(string, string)?>
var pipeline = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: NodeIsEligibleForGeneration,
                transform: TransformNode)
            .Where(static x => x.HasValue) // filter out null
            .Select(static (x, _) => x!.Value) // force result to the nullable value so GenerateOutput doesn't receive null parameters
```

Next, change the method signature of `GenerateOutput` to match our new result type.

```csharp
private static void GenerateOutput(SourceProductionContext context,
        (string NamespaceName, string ClassName) classToGenerate)
```

And finally, update the content of `GenerateOutput` to add the class shell to the output.

```csharp
private static void GenerateOutput(SourceProductionContext context,
        (string NamespaceName, string ClassName) classToGenerate)
    {   
        // use an interopolated multi-line string for simplicity. 
        // This could also be done with a StringBuilder or some type of class builder.
        var sourceText = $@"/// <auto-generated>
namespace {classToGenerate.NamespaceName}
{{
    partial class {classToGenerate.ClassName}
    {{
    }}
}}";

        context.AddSource($"{classToGenerate.NamespaceName}.{classToGenerate.ClassName}.g.cs", sourceText);
    }
```

### Update Unit Test

Let's update the unit test to assert the changes to generated code.

```csharp
// add constants to hold expected output
private const string ExpectedFileName = "AutoProperty.Sample.Book.g.cs";

private const string ExpectedGeneratedText = @"/// <auto-generated>
namespace AutoProperty.Sample
{
    partial class Book
    {
    }
}";

// update assertion to use constants
Assert.Collection(result.GeneratedTrees, tree =>
{
    Assert.Equal(ExpectedFileName, Path.GetFileName(tree.FilePath));
    Assert.Equal(ExpectedGeneratedText, tree.GetText().ToString());
});
```


### Wrapping Up

If you build the solution after completing the above changes, you should see `AutoProperty.Sample.Book.g.cs` created with the class shell.

You might still see the old `Book.g.cs` in the generated output folder. If so, you can delete that from disk.

If you skipped the update to adding `partial` to `Book`, after building the solution you should see a compile error:

`Duplicate definition 'AutoProperty.Sample.Book'. Possibly missing keyword 'partial'`

In the next exercise we'll work with the semantic model to get interface metadata and add it to the generated output.