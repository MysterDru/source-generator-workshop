## Exercise 5 | Working With the Semantic Model

Now we're ready to generate our missing interface properties.

So far we've done some basic work with the Syntax Tree to get information about the class we're generating code for. Now we need to evaluate what properties are missing in the class implementation for an interface. To do that, we'll work with the Semantic Model Api of Roslyn. This will be similar to working with reflection to evaluate type metadata.

### Update TransformNode

First, we'll update the `TransformNode` method of our generator to get the class name and namespace from the semantic model instead of the syntax tree.

```csharp
private static (string NamespaceName, string ClassName)? TransformNode(GeneratorSyntaxContext generatorContext,
        CancellationToken cancellationToken)
    {
        var classDeclaration = (ClassDeclarationSyntax) generatorContext.Node;

        var symbol = generatorContext.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken);
        // Classes (and interfaces) are represented as an INamedTypeSymbol in the model
        // INamedTypeSymbol is conceptually similar to System.Type
        if (symbol is not INamedTypeSymbol classSymbol)
        {
            // this shouldn't happen, given we're filtering to ClassDeclarations. But having it puts a safe guard in place so the generator does fail/crash.
            return null; 
        }

        return (
            classSymbol.ContainingNamespace.ToDisplayString(), 
            classSymbol.Name
        );
    }
```

If we did everything correctly, our unit test should still pass. We didn't change the structure of the output, just how we're retrieving the metadata.

### Return Properties Defined on Interfaces But Not On Class

Let's update the transform and generate methods to account for an additional collection properties that need to be implemented.

```csharp
private static (string NamespaceName, string ClassName, string[] Properties)? TransformNode(GeneratorSyntaxContext generatorContext,
        CancellationToken cancellationToken)

private static void GenerateOutput(SourceProductionContext context,
        (string NamespaceName, string ClassName, string[] PropertyNames) classToGenerate)
```

Now we'll find all interfaces that are implemented by the class, and determine if there are any properties that haven't been implemented by the developer. To keep things simple to start, we'll just look at the property names.

Replace the return statement of `TransformNode` with the following code block:


```csharp
// Get a list of all the properties implemented by the class.
var classProperties = classSymbol
    .GetMembers()
    .OfType<IPropertySymbol>()
    .ToList();

// Get all the interfaces implemented by the class, and all properties from each interface.
var interfaceProperties = classSymbol.AllInterfaces
    .SelectMany(i => i.GetMembers().OfType<IPropertySymbol>())
    .ToList();

// Compare and filter out any properties that are already implemented by the class 
var unimplementedProperties = interfaceProperties
    .Select(p => p.Name)
    .Where(p => classProperties.All(x => x.Name != p))
    .ToArray();

// Add the unimplemented properties in the return result
return (
    classSymbol.ContainingNamespace.ToDisplayString(), 
    classSymbol.Name, 
    unimplementedProperties
);
```

This logic will get expanded on later, but for now this will allow us to populate our generated output with the context of the missing properties.

You may choose to modify the LINQ statements to standard for loops to allow for easier debugging and inspecting of results.

#### Add Placeholder Details for Unimplemented Properties

We can now update the Generate method to add comments as placeholders for the properties. Since we're only retrieving property names right now we can't add complete code.

Replace the `sourceText` variable assignment in `GenerateOutput` with the following:

```csharp
var propertyPlaceholders = string.Join("\n\n\t\t\t", classToGenerate.PropertyNames.Select(p => $"// {p}"));
        
var sourceText = $@"/// <auto-generated>
namespace {classToGenerate.NamespaceName}
{{
    partial class {classToGenerate.ClassName}
    {{
        {propertyPlaceholders}
    }}
}}";
```

#### Test The Changes

You won't initially see the property comments in the generated output. Since our generator only adds unimplemented properties, we need to force that condition.

Update the `Book` class so it doesn't have the LastUpdatedDate property anymore.

```csharp
public partial class Book : IAuditMetadata
{
    public required string Title { get; set; }

    public required string Author { get; set; }
}
```

In the sample project, you'll get a compile error since the property isn't currently implemented. However you should see the updated output in the generated file. 

```csharp
/// <auto-generated>
namespace AutoProperty.Sample
{
    partial class Book
    {
        // LastUpdated
    }
}
```

Updating the unit test should yield a similar result.

#### Generating the Property Definition

Now we can work through generating the full property definition of the unimplemented properties.

In the `TransformNode` method, replace the LINQ statement and variable assignment with this updated statement:

```csharp
// Add the unimplemented properties in the return result with the implementation format of:
// public Type Name { get; set; } // or { get; init; }
var unimplementedProperties = interfaceProperties
    .Where(i => !classProperties.Exists(c => c.Name == i.Name))
    .Select(i =>
    {
        var getAccessor = i.GetMethod != null ? "get;" : "";
        var setAccessor = i.SetMethod != null ? "set;" : "";

        setAccessor = i.SetMethod?.IsInitOnly ?? false ? "init;" : setAccessor;

        return $"public {i.Type} {i.Name} {{ {getAccessor} {setAccessor} }}";
    })
    .ToArray();
```

Here, we've updated the LINQ statement to filter out any interface properties already on the class. Then, we're constructing the formatted property implementation

Next, update the `GenerateOutput` so that the property format renders as the real properties instead of a comment:

```csharp
var properties = string.Join("\n\n\t\t\t", classToGenerate.PropertyNames);
```

#### Verfiy the Output

If you build the solution and view the generated code (or debug and run the tests), you should see the following in the generated output:

```csharp
/// <auto-generated>
namespace AutoProperty.Sample
{
    partial class Book
    {
        public System.DateTimeOffset LastUpdated { get; set; }
    }
}
```

The unit test should be failing now as well, so update the `ExpectedGeneratedText` constant to match the expected source above.

##### Additional Output

- What happens if you add more properties to the `IAuditMetadata` interface?

- What happens if you create another interface and add it to the `Book` class without implementing it's properties?

- What happens if you add another class? Maybe an `Author?`

Give it a try. Create different permutations of interfaces, classes, and properties.

Below are some examples

```csharp
public interface IHasId
{
    public int Id { get; set; }
}

public interface IHasTitle
{
    public string Title { get; set; }
}

public interface IHasActiveFlag
{
    public bool IsActive { get; set; }
}

public interface IAuditMetadata
{
    DateTimeOffset LastUpdated { get; set; }

    bool IsEditable { get; }
}
```

```csharp
public partial class Author : IHasId, IHasActiveFlag, IAuditMetadata
{
    public required string Name { get; set; }
}

public partial class Book : IHasId, IHasTitle, IHasActiveFlag, IAuditMetadata
{
    public required string Title { get; set; }

    public required string Author { get; set; }
}
```

If you add multiple classes, unit tests will have to be updated to account for multiple generated files:

```csharp
// update assertions for multiple generated tree
Assert.Collection(result.GeneratedTrees,
    tree =>
    {
        Assert.Equal("AutoProperty.Sample.Author.g.cs", Path.GetFileName(tree.FilePath));
        Assert.Equal(@"/// <auto-generated>
namespace AutoProperty.Sample
{
    partial class Author
    {
        public int Id { get; set; }

			public bool IsActive { get; set; }

			public DateTimeOffset LastUpdated { get; set; }

			public bool IsEditable { get;  }
    }
}", tree.GetText().ToString());
    },
    tree =>
    {
        Assert.Equal("AutoProperty.Sample.Book.g.cs", Path.GetFileName(tree.FilePath));
        Assert.Equal(@"/// <auto-generated>
namespace AutoProperty.Sample
{
    partial class Book
    {
        public int Id { get; set; }

			public bool IsActive { get; set; }

			public DateTimeOffset LastUpdated { get; set; }

			public bool IsEditable { get;  }
    }
}", tree.GetText().ToString());
    });
```

#### Wrapping Up

We now have a generator implementation that generates missing property implementations on a class! As well as handling multiple interface implementations and more than 1 class declaration.

We're not done yet though, there are some things we need to do to optimize the generator. We'll go through that next.