## Exercise 5 | Working With the Semantic Model

Now we're ready to generate our missing interface properties.

So far we've done some basic work with the Syntax Tree to get information about the class we're generating code for. Now we need to evaluate what properties are missing in the class implementation for an interface. To do that, we'll work with the Semantic Model Api of Roslyn. This will be similar to working with reflection to evaluate type metadata.

### Update TransformNode

First, we'll update the `TransformNode` method of our generator to get the class name and namespace from the semantic model instead of the syntax tree.

```csharp
private static (string NamespaceName, string ClassName)? TransformNode(GeneratorSyntaxContext generatorContext,
        CancellationToken cancellationToken)
    {
        var classDeclaration = (ClassDeclarationSyntax) generatorContext.Node;

        var symbol = generatorContext.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken);
        // Classes (and interfaces) are represented as an INamedTypeSymbol in the model
        // INamedTypeSymbol is conceptually similar to System.Type
        if (symbol is not INamedTypeSymbol classSymbol)
        {
            // this shouldn't happen, given we're filtering to ClassDeclarations. But having it puts a safe guard in place so the generator does fail/crash.
            return null; 
        }

        return (
            classSymbol.ContainingNamespace.ToDisplayString(), 
            classSymbol.Name
        );
    }
```

If we did everything correctly, our unit test should still pass. We didn't change the structure of the output, just how we're retrieving the metadata.

### Return Properties Defined on Interfaces But Not On Class

Let's update the transform and generate methods to account for an additional collection properties that need to be implemented.

```csharp
private static (string NamespaceName, string ClassName, string[] Properties)? TransformNode(GeneratorSyntaxContext generatorContext,
        CancellationToken cancellationToken)

private static void GenerateOutput(SourceProductionContext context,
        (string NamespaceName, string ClassName, string[] PropertyNames) classToGenerate)
```

Now we'll find all interfaces that are implemented by the class, and determine if there are any properties that haven't been implemented by the developer. To keep things simple to start, we'll just look at the property names.


```csharp
// Get a list of all the properties implemented by the class.
var classProperties = classSymbol.GetMembers().OfType<IPropertySymbol>();

// Get all the interfaces implemented by the class, and all properties from each interface.
var interfaceProperties = classSymbol.AllInterfaces.SelectMany(i => i.GetMembers().OfType<IPropertySymbol>());

// Compare and filter out any properties that are already implemented by the class 
var unimplementedPropertyNames = interfaceProperties
    .Select(p => p.Name)
    .Where(p => classProperties.All(x => x.Name != p))
    .ToArray();

// Add the unimplemented properties in the return result
return (
    classSymbol.ContainingNamespace.ToDisplayString(), 
    classSymbol.Name, 
    unimplementedPropertyNames
);
```

This logic will get expanded on later, but for now this will allow us to populate our generated output with the context of the missing properties.

You may choose to modify the LINQ statements to standard for loops to allow for easier debugging and inspecting of results.

#### Add Placeholder Details for Unimplemented Properties

We can now update the Generate method to add comments as placeholders for the properties. Since we're only retrieving property names right now we can't add complete code.

```csharp
var propertyPlaceholders = string.Join("\n\n\t\t\t", classToGenerate.PropertyNames.Select(p => $"// {p}"));
        
var sourceText = $@"/// <auto-generated>
namespace {classToGenerate.NamespaceName}
{{
    partial class {classToGenerate.ClassName}
    {{
        {propertyPlaceholders}
    }}
}}";
```

#### Test The Changes

You won't initially see the property comments in the generated output. Since our generator only adds unimplemented properties, we need to force that condition.

Update the `Book` class so it doesn't have the LastUpdatedDate property anymore.

```csharp
public partial class Book : IAuditMetadata
{
    public required string Title { get; set; }

    public required string Author { get; set; }
}
```

In the sample project, you'll get a compile error since the property isn't currently implemented. However you should see the updated output in the generated file. 

```csharp
/// <auto-generated>
namespace AutoProperty.Sample
{
    partial class Book
    {
        // LastUpdated
    }
}
```

Updating the unit test should yield a similar result.

#### Generating the Property Definition

Now we can work through generating the full property definition of the unimplemented properties.