### Exercise 8 - Final Optimizations

We have a working generator, but right now this generator will run for every class that has interfaces even if we don't want an interface to be processed by the generator.

Lets use a **Marker Attribute** to indicate what interfaces should be autogenerated by the generator.


#### Create the Attribute

First, we'll create a marker attribute that can be consumed by the project to indicate an interface that should be processed.

We can create a marker attribute (or any other code) with our generator that will be added to the consuming project when the generator is first initialized. This will be a 1-time code generation.

Add the following to the beginning of the `Initialize` method in the generator class.

```csharp
context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("AutoPropertyAttribute.g.cs", @"/// <auto-generated/>
using System;
namespace AutoProperty.Generator;

[AttributeUsage(AttributeTargets.Assembly, Inherited = false, AllowMultiple = true)]
public class AutoPropertyAttribute(Type @interface) : Attribute 
{
}");
        });
```

Now when you clean and rebuild, you'll see a `AutoPropertyAttribute.g.cs` in the generated files area of the sample project. 

Update `Program.cs` to add an assembly level attribute:

```csharp
[assembly: AutoProperty.Generator.AutoProperty(typeof(IAuditMetadata))]
```

#### Fix an Error

Right now, we have an issue in our `TransformationNode` method. We don't filter out and ignore classes that:

a) Don't have interfaces defined
b) Dont' have unimplemented properties

As a result, when we add the marker attribute, our custom attribute will get processed by the generator. We need to update `TransformNode` to not generate in those scenarios.

```csharp
// Add this before building the classProperties list
if (classSymbol.AllInterfaces.Length == 0)
{
    return null;
}

// add this after building the unimplementedProperties list
if (unimplementedProperties.Length == 0)
{
    return null;
}
```

After adding this, the project should build successfuly.

### Process the Attribute

Next, we need to look for this attribute in the generator and update our pipeline to only generate classes that have this interface.

After the above post initialization call, add the following syntax provider pipeline:

```csharp
var interfacePipeline = context.SyntaxProvider.ForAttributeWithMetadataName(
    "AutoProperty.Generator.AutoPropertyAttribute",
    (x, _) => true,
    (x, _) =>
    {
        var interfaceNames = x.Attributes.Where(a => a.AttributeClass?.Name == "AutoPropertyAttribute")
            .Select(a => (a.ConstructorArguments[0].Value as INamedTypeSymbol)?.MetadataName)
            .ToArray();

        return new EquatableArray<string>(interfaceNames);
    });
```

This pipeline uses a optimized helper method provided by the roslyn sdk to look for any syntax nodes that have an attribute with a particular metdata name. In our case, it will be the compilation syntax for the program class.

We don't need to add a predicate because the attribute helper method does that for us, but it provides the option to filter things further.

Then, we add a transformation method that will select the interface metadata name, which we can use for further matching on our class properties.

Next, we need to expose the interface name on our class & property info name to be matched against the attribute list.

Update the `PropertyToGenerate` record to have a new property:

```csharp
public string InterfaceName { get; set; }
```

And then set that property in the select statement within `TransformNode`

```csharp
.Select(i => new PropertyToGenerate()
{
    InterfaceName = i.ContainingType?.MetadataName,
    Visibility = "public",
    Type = i.Type.ToDisplayString(),
    Name = i.Name,
    HasGet = i.GetMethod != null,
    HasSet = i.SetMethod != null,
    IsInit = i.SetMethod is {IsInitOnly: true},
})
```

When creating a single generatied output, all pipelines need to be merged together. This can be done using a `Combine` method on the generator.

We now want to merge the list of interfaces and class metadata together, and filter out any classes or properties that are not approprate for the list of interfaces.

Update the call for `RegisterSourceOutput` in the `Initialize` method:

```csharp
var combinedPipeline = interfacePipeline
    .Combine(pipeline.Collect())
    .SelectMany(FlattenResult);

context.RegisterSourceOutput(combinedPipeline, GenerateOutput);
```

The `.Combine` method will merge the pipelines together using `.Collect` on our original pipeline. Collect is necessary to convert the pipeline to an immutable array. This is related to how the pipeline aggregates results in the final result.

We add a new `FlattenResult` static method that will be used to flatten and filter our the `ClassToGenerate` values to only sets of data that match the registered interfaces. Add the following implementation for `FlattenResult` somewhere in the generator class.

```csharp
private static ImmutableArray<ClassToGenerate> FlattenResult(
    (EquatableArray<string> Interfaces, ImmutableArray<ClassToGenerate> ClassesToGenerate) tuple,
    CancellationToken cancellationToken)
{
    var classesToGenerate = tuple.ClassesToGenerate;
    var interfaces = tuple.Interfaces;

    List<ClassToGenerate> result = new();
    foreach (var classToGenerate in classesToGenerate)
    {
        var filteredProperties = classToGenerate.Properties.Where(p => interfaces.Contains(p.InterfaceName))
            .ToArray();

        if (filteredProperties.Length == 0)
        {
            continue;
        }

        result.Add(classToGenerate with
        {
            Properties = new EquatableArray<PropertyToGenerate>(filteredProperties)
        });
    }

    return result.ToImmutableArray();
}
```

This method will filter out any class property metadata that doesn't belong to interfaces we care about.


### Test The Result

If you build the solution now, you'll likely get a compile error. We didn't add attributes for `IHasId` or `IHasActiveFlag`

You'll either need to implement those interfaces, or register them.

```csharp
[assembly: AutoProperty.Generator.AutoProperty(typeof(IHasId))]
[assembly: AutoProperty.Generator.AutoProperty(typeof(IHasActiveFlag))]
```

Now, you should successfuly build and see generated output for only the interfaces that are registered.

### Wrapping Up

Congrats! You've reached the end of the exercises for this workshop. 

These exercises have taken you through the full lifecycle of building a source generator and should give some tools to take away to make your own in the future.

This completes the exercises for today. Well done! From here, with any time remaining in tthe workshop, we'll talk about any other topics or question the group has.